name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: false
        default: 'latest'

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      SERVER_USER: ${{ secrets.SERVER_USER }}
      SERVER_HOST: ${{ secrets.SERVER_HOST }}
      APP_DIR: ${{ secrets.APP_DIR || '/root/code/finance-tracker' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy to production server
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          APP_DIR: ${{ secrets.APP_DIR || '/root/code/finance-tracker' }}
          DOMAIN: ${{ secrets.DOMAIN_PRODUCTION }}
          FRONTEND_HOST: ${{ secrets.FRONTEND_HOST || format('https://dashboard.{0}', secrets.DOMAIN_PRODUCTION) }}
          BACKEND_CORS_ORIGINS: ${{ secrets.BACKEND_CORS_ORIGINS || format('https://dashboard.{0},https://api.{0}', secrets.DOMAIN_PRODUCTION) }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          FIRST_SUPERUSER: ${{ secrets.FIRST_SUPERUSER }}
          FIRST_SUPERUSER_PASSWORD: ${{ secrets.FIRST_SUPERUSER_PASSWORD }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          EMAILS_FROM_EMAIL: ${{ secrets.EMAILS_FROM_EMAIL }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT || '5432' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB || 'app' }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'postgres' }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN || '' }}
          STACK_NAME: ${{ secrets.STACK_NAME || 'wiseman-palace-production' }}
          TAG: ${{ inputs.image_tag || 'latest' }}
          SMTP_PORT: ${{ secrets.SMTP_PORT || '587' }}
          SMTP_TLS: ${{ secrets.SMTP_TLS || 'True' }}
          SMTP_SSL: ${{ secrets.SMTP_SSL || 'False' }}
          EMAILS_FROM_NAME: ${{ secrets.EMAILS_FROM_NAME || 'Finance Tracker' }}
        run: |
          ssh -o StrictHostKeyChecking=accept-new ${SERVER_USER}@${SERVER_HOST} \
            "APP_DIR='$APP_DIR' \
             GIT_REPOSITORY='${{ github.repository }}' \
             DOMAIN='$DOMAIN' \
             FRONTEND_HOST='$FRONTEND_HOST' \
             BACKEND_CORS_ORIGINS='$BACKEND_CORS_ORIGINS' \
             SECRET_KEY='$SECRET_KEY' \
             FIRST_SUPERUSER='$FIRST_SUPERUSER' \
             FIRST_SUPERUSER_PASSWORD='$FIRST_SUPERUSER_PASSWORD' \
             SMTP_HOST='$SMTP_HOST' \
             SMTP_USER='$SMTP_USER' \
             SMTP_PASSWORD='$SMTP_PASSWORD' \
             EMAILS_FROM_EMAIL='$EMAILS_FROM_EMAIL' \
             POSTGRES_PORT='$POSTGRES_PORT' \
             POSTGRES_DB='$POSTGRES_DB' \
             POSTGRES_USER='$POSTGRES_USER' \
             POSTGRES_PASSWORD='$POSTGRES_PASSWORD' \
             SENTRY_DSN='$SENTRY_DSN' \
             STACK_NAME='$STACK_NAME' \
             TAG='$TAG' \
             SMTP_PORT='$SMTP_PORT' \
             SMTP_TLS='$SMTP_TLS' \
             SMTP_SSL='$SMTP_SSL' \
             EMAILS_FROM_NAME='$EMAILS_FROM_NAME' \
             bash -s" << 'ENDSSH'
          set -euo pipefail
          
          # Ensure Docker is in PATH for non-interactive shells
          # Try common Docker installation locations
          for docker_path in /usr/bin/docker /usr/local/bin/docker /snap/bin/docker $(command -v docker); do
            if [ -x "$docker_path" ] 2>/dev/null; then
              export PATH="$(dirname $docker_path):$PATH"
              break
            fi
          done
          
          export PATH=$PATH:/usr/bin:/usr/local/bin:/snap/bin
          
          # Load environment if .bashrc or .profile exists
          [ -f ~/.bashrc ] && source ~/.bashrc || true
          [ -f ~/.profile ] && source ~/.profile || true
          
          # Validate required envs
          if [ -z "${DOMAIN:-}" ]; then echo "ERROR: DOMAIN is not set"; exit 1; fi
          if [ -z "${SECRET_KEY:-}" ]; then echo "ERROR: SECRET_KEY is not set"; exit 1; fi
          
          APP_DIR_PATH="${APP_DIR:-/root/code/finance-tracker}"
          
          # Clone repository if it doesn't exist
          if [ ! -d "${APP_DIR_PATH}/.git" ]; then
            echo "Repository not found on server. Cloning fresh copy..."
            rm -rf "${APP_DIR_PATH}"
            mkdir -p "${APP_DIR_PATH}"
            
            # Try HTTPS first, fallback to SSH if available
            if ! git clone "https://github.com/${GIT_REPOSITORY}.git" "${APP_DIR_PATH}" 2>&1; then
              echo "HTTPS clone failed, trying SSH..."
              if ! git clone "git@github.com:${GIT_REPOSITORY}.git" "${APP_DIR_PATH}" 2>&1; then
                echo "ERROR: Failed to clone repository via both HTTPS and SSH"
                echo "This might be a network connectivity issue or authentication problem"
                exit 1
              fi
            fi
          fi
          
          cd "${APP_DIR_PATH}"
          
          # Pull latest code from GitHub with retry logic
          echo "Fetching latest code..."
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git fetch origin 2>&1; then
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Git fetch failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
                sleep 5
              else
                echo "ERROR: Failed to fetch from GitHub after $MAX_RETRIES attempts"
                echo "Using existing code if available..."
              fi
            fi
          done
          
          # Reset to latest only if fetch succeeded
          if git fetch origin 2>&1 >/dev/null; then
            git reset --hard origin/master || git reset --hard origin/main
          else
            echo "WARNING: Using existing code due to fetch failure"
          fi
          
          # Set environment variables for docker-compose
          export ENVIRONMENT=production
          export POSTGRES_SERVER=db
          export DOCKER_IMAGE_BACKEND=wiseman-palace-backend
          export DOCKER_IMAGE_FRONTEND=wiseman-palace-frontend
          export TAG=${TAG:-latest}
          
          # Create .env file from environment variables
          echo "Creating .env file..."
          {
            echo "DOMAIN=${DOMAIN}"
            echo "FRONTEND_HOST=${FRONTEND_HOST}"
            echo "ENVIRONMENT=production"
            echo "PROJECT_NAME=Finance Tracker"
            echo "STACK_NAME=${STACK_NAME:-wiseman-palace-production}"
            echo "BACKEND_CORS_ORIGINS=${BACKEND_CORS_ORIGINS}"
            echo "SECRET_KEY=${SECRET_KEY}"
            echo "FIRST_SUPERUSER=${FIRST_SUPERUSER}"
            echo "FIRST_SUPERUSER_PASSWORD=${FIRST_SUPERUSER_PASSWORD}"
            echo "SMTP_HOST=${SMTP_HOST:-}"
            echo "SMTP_USER=${SMTP_USER:-}"
            echo "SMTP_PASSWORD=${SMTP_PASSWORD:-}"
            echo "SMTP_PORT=${SMTP_PORT:-587}"
            echo "SMTP_TLS=${SMTP_TLS:-True}"
            echo "SMTP_SSL=${SMTP_SSL:-False}"
            echo "EMAILS_FROM_EMAIL=${EMAILS_FROM_EMAIL:-}"
            echo "EMAILS_FROM_NAME=${EMAILS_FROM_NAME:-Finance Tracker}"
            echo "POSTGRES_SERVER=db"
            echo "POSTGRES_PORT=${POSTGRES_PORT}"
            echo "POSTGRES_DB=${POSTGRES_DB}"
            echo "POSTGRES_USER=${POSTGRES_USER}"
            echo "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}"
            echo "SENTRY_DSN=${SENTRY_DSN:-}"
            echo "DOCKER_IMAGE_BACKEND=${DOCKER_IMAGE_BACKEND}"
            echo "DOCKER_IMAGE_FRONTEND=${DOCKER_IMAGE_FRONTEND}"
            echo "TAG=${TAG}"
          } > .env
          echo ".env file created"
          
          # Verify Docker is available - try multiple methods
          echo "Checking Docker installation..."
          DOCKER_CMD=""
          for cmd in docker /usr/bin/docker /usr/local/bin/docker /snap/bin/docker; do
            if $cmd --version &>/dev/null; then
              DOCKER_CMD="$cmd"
              echo "Docker found at: $DOCKER_CMD"
              $cmd --version
              break
            fi
          done
          
          if [ -z "$DOCKER_CMD" ]; then
            echo "ERROR: Docker command not found"
            echo "PATH: $PATH"
            echo "Trying to find docker..."
            find /usr -name docker -type f 2>/dev/null | head -3
            exit 1
          fi
          
          # Create traefik-public network if it doesn't exist
          echo "Checking traefik-public network..."
          if ! $DOCKER_CMD network inspect traefik-public &>/dev/null; then
            echo "Creating traefik-public network..."
            $DOCKER_CMD network create traefik-public
          else
            echo "traefik-public network already exists"
          fi
          
          # Build and deploy using found docker command
          echo "Building Docker images..."
          # Use docker compose (plugin) - this is what's installed with modern Docker
          $DOCKER_CMD compose -f docker-compose.yml build
          
          echo "Starting services..."
          # Start services and capture output
          if ! $DOCKER_CMD compose -f docker-compose.yml up -d; then
            echo "ERROR: Services failed to start"
            echo "Checking prestart logs..."
            $DOCKER_CMD compose logs prestart 2>&1 || true
            echo "Checking all service status..."
            $DOCKER_CMD compose ps -a
            exit 1
          fi
          
          # Wait a moment for services to initialize
          sleep 5
          
          # Check prestart container status and logs
          echo "Checking prestart service status..."
          PRESTART_CONTAINER=$($DOCKER_CMD compose ps -q prestart 2>/dev/null || true)
          if [ -n "$PRESTART_CONTAINER" ]; then
            PRESTART_STATUS=$($DOCKER_CMD inspect $PRESTART_CONTAINER --format='{{.State.Status}}' 2>/dev/null || echo "unknown")
            if [ "$PRESTART_STATUS" = "exited" ]; then
              PRESTART_EXIT=$($DOCKER_CMD inspect $PRESTART_CONTAINER --format='{{.State.ExitCode}}' 2>/dev/null || echo "unknown")
              if [ "$PRESTART_EXIT" != "0" ] && [ "$PRESTART_EXIT" != "unknown" ]; then
                echo "ERROR: Prestart service failed with exit code $PRESTART_EXIT"
                echo "Prestart logs:"
                $DOCKER_CMD compose logs prestart 2>&1
                exit 1
              fi
            fi
          fi
          
          # Restart supervisor processes in backend container
          echo "Restarting supervisor processes..."
          BACKEND_CONTAINER=$($DOCKER_CMD compose ps -q backend 2>/dev/null || $DOCKER_CMD ps -q -f name=backend)
          if [ -n "$BACKEND_CONTAINER" ]; then
            $DOCKER_CMD exec $BACKEND_CONTAINER supervisorctl restart all || true
          fi
          
          echo "Deployment completed successfully!"
          
          # Show service status
          $DOCKER_CMD compose ps
          ENDSSH

      - name: Verify deployment
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          APP_DIR: ${{ secrets.APP_DIR || '/root/code/finance-tracker' }}
        run: |
          ssh -o StrictHostKeyChecking=accept-new ${SERVER_USER}@${SERVER_HOST} \
            "export PATH=\$PATH:/usr/bin:/usr/local/bin && cd ${APP_DIR} && docker compose ps && docker compose logs --tail=20 backend"

