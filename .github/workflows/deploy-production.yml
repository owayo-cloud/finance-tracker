name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: false
        default: 'latest'

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 60  # Increased from 30 to 60 minutes
    env:
      SERVER_USER: ${{ secrets.SERVER_USER }}
      SERVER_HOST: ${{ secrets.SERVER_HOST }}
      APP_DIR: ${{ secrets.APP_DIR || '/root/code/finance-tracker' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Verify server connectivity
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
        run: |
          echo "Testing SSH connectivity to ${SERVER_USER}@${SERVER_HOST}..."
          MAX_RETRIES=5
          RETRY_COUNT=0
          RETRY_DELAY=10
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if ssh -o StrictHostKeyChecking=accept-new \
                   -o ConnectTimeout=10 \
                   -o ServerAliveInterval=30 \
                   -o ServerAliveCountMax=3 \
                   -o TCPKeepAlive=yes \
                   ${SERVER_USER}@${SERVER_HOST} \
                   "echo 'Connection successful' && uptime"; then
              echo "✓ Server is reachable"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "⚠ Connection attempt $RETRY_COUNT/$MAX_RETRIES failed. Retrying in ${RETRY_DELAY} seconds..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              else
                echo "✗ Failed to connect after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Deploy to production server
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          APP_DIR: ${{ secrets.APP_DIR || '/root/code/finance-tracker' }}
          DOMAIN: ${{ secrets.DOMAIN_PRODUCTION }}
          FRONTEND_HOST: ${{ secrets.FRONTEND_HOST || format('https://dashboard.{0}', secrets.DOMAIN_PRODUCTION) }}
          BACKEND_CORS_ORIGINS: ${{ secrets.BACKEND_CORS_ORIGINS || format('https://dashboard.{0},https://api.{0}', secrets.DOMAIN_PRODUCTION) }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          FIRST_SUPERUSER: ${{ secrets.FIRST_SUPERUSER }}
          FIRST_SUPERUSER_PASSWORD: ${{ secrets.FIRST_SUPERUSER_PASSWORD }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          EMAILS_FROM_EMAIL: ${{ secrets.EMAILS_FROM_EMAIL }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT || '5432' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB || 'app' }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'postgres' }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN || '' }}
          STACK_NAME: ${{ secrets.STACK_NAME || 'wiseman-palace-production' }}
          TAG: ${{ inputs.image_tag || 'latest' }}
          SMTP_PORT: ${{ secrets.SMTP_PORT || '587' }}
          SMTP_TLS: ${{ secrets.SMTP_TLS || 'True' }}
          SMTP_SSL: ${{ secrets.SMTP_SSL || 'False' }}
          EMAILS_FROM_NAME: ${{ secrets.EMAILS_FROM_NAME || 'WiseManPalace' }}
        run: |
          MAX_SSH_RETRIES=3
          SSH_RETRY_COUNT=0
          SSH_RETRY_DELAY=5
          
          while [ $SSH_RETRY_COUNT -lt $MAX_SSH_RETRIES ]; do
            echo "SSH connection attempt $((SSH_RETRY_COUNT + 1))/$MAX_SSH_RETRIES..."
            if ssh -o StrictHostKeyChecking=accept-new \
                   -o ServerAliveInterval=30 \
                   -o ServerAliveCountMax=10 \
                   -o TCPKeepAlive=yes \
                   -o ConnectTimeout=15 \
                   -o BatchMode=yes \
                   ${SERVER_USER}@${SERVER_HOST} \
                   "APP_DIR='${APP_DIR}' \
                   GIT_REPOSITORY='${{ github.repository }}' \
                   DOMAIN='${DOMAIN}' \
                   FRONTEND_HOST='${FRONTEND_HOST}' \
                   BACKEND_CORS_ORIGINS='${BACKEND_CORS_ORIGINS}' \
                   SECRET_KEY='${SECRET_KEY}' \
                   FIRST_SUPERUSER='${FIRST_SUPERUSER}' \
                   FIRST_SUPERUSER_PASSWORD='${FIRST_SUPERUSER_PASSWORD}' \
                   SMTP_HOST='${SMTP_HOST}' \
                   SMTP_USER='${SMTP_USER}' \
                   SMTP_PASSWORD='${SMTP_PASSWORD}' \
                   EMAILS_FROM_EMAIL='${EMAILS_FROM_EMAIL}' \
                   POSTGRES_PORT='${POSTGRES_PORT}' \
                   POSTGRES_DB='${POSTGRES_DB}' \
                   POSTGRES_USER='${POSTGRES_USER}' \
                   POSTGRES_PASSWORD='${POSTGRES_PASSWORD}' \
                   SENTRY_DSN='${SENTRY_DSN}' \
                   STACK_NAME='${STACK_NAME}' \
                   TAG='${TAG}' \
                   SMTP_PORT='${SMTP_PORT}' \
                   SMTP_TLS='${SMTP_TLS}' \
                   SMTP_SSL='${SMTP_SSL}' \
                   EMAILS_FROM_NAME='${EMAILS_FROM_NAME}' \
                   bash -s" << 'ENDSSH'
          export APP_DIR GIT_REPOSITORY DOMAIN FRONTEND_HOST BACKEND_CORS_ORIGINS
          export SECRET_KEY FIRST_SUPERUSER FIRST_SUPERUSER_PASSWORD
          export SMTP_HOST SMTP_USER SMTP_PASSWORD EMAILS_FROM_EMAIL
          export POSTGRES_PORT POSTGRES_DB POSTGRES_USER POSTGRES_PASSWORD
          export SENTRY_DSN STACK_NAME TAG SMTP_PORT SMTP_TLS SMTP_SSL EMAILS_FROM_NAME
          
          set -euo pipefail
          
          # Find Docker
          for docker_path in /usr/bin/docker /usr/local/bin/docker /snap/bin/docker $(command -v docker); do
            if [ -x "$docker_path" ] 2>/dev/null; then
              export PATH="$(dirname $docker_path):$PATH"
              break
            fi
          done
          
          export PATH=$PATH:/usr/bin:/usr/local/bin:/snap/bin
          [ -f ~/.bashrc ] && source ~/.bashrc || true
          [ -f ~/.profile ] && source ~/.profile || true
          
          if [ -z "${DOMAIN:-}" ]; then echo "ERROR: DOMAIN is not set"; exit 1; fi
          if [ -z "${SECRET_KEY:-}" ]; then echo "ERROR: SECRET_KEY is not set"; exit 1; fi
          
          APP_DIR_PATH="${APP_DIR:-/root/code/finance-tracker}"
          
          # Clone or update repository
          if [ ! -d "${APP_DIR_PATH}/.git" ]; then
            echo "Cloning repository..."
            rm -rf "${APP_DIR_PATH}"
            mkdir -p "${APP_DIR_PATH}"
            git clone "https://github.com/${GIT_REPOSITORY}.git" "${APP_DIR_PATH}" || \
            git clone "git@github.com:${GIT_REPOSITORY}.git" "${APP_DIR_PATH}"
          fi
          
          cd "${APP_DIR_PATH}"
          
          echo "Fetching latest code..."
          git fetch origin 2>&1 && (git reset --hard origin/master || git reset --hard origin/main) || \
          echo "WARNING: Using existing code"
          
          # Set environment variables
          export ENVIRONMENT=production
          export POSTGRES_SERVER=db
          export DOCKER_IMAGE_BACKEND=wiseman-palace-backend
          export DOCKER_IMAGE_FRONTEND=wiseman-palace-frontend
          export TAG=${TAG:-latest}
          
          # Create .env file
          echo "Creating .env file..."
          {
            echo "DOMAIN=${DOMAIN}"
            echo "FRONTEND_HOST=${FRONTEND_HOST}"
            echo "ENVIRONMENT=production"
            echo "PROJECT_NAME=WiseManPalace"
            echo "STACK_NAME=${STACK_NAME:-wiseman-palace-production}"
            echo "BACKEND_CORS_ORIGINS=${BACKEND_CORS_ORIGINS}"
            echo "SECRET_KEY=${SECRET_KEY}"
            echo "FIRST_SUPERUSER=${FIRST_SUPERUSER}"
            echo "FIRST_SUPERUSER_PASSWORD=${FIRST_SUPERUSER_PASSWORD}"
            echo "SMTP_HOST=${SMTP_HOST:-}"
            echo "SMTP_USER=${SMTP_USER:-}"
            echo "SMTP_PASSWORD=${SMTP_PASSWORD:-}"
            echo "SMTP_PORT=${SMTP_PORT:-587}"
            echo "SMTP_TLS=${SMTP_TLS:-True}"
            echo "SMTP_SSL=${SMTP_SSL:-False}"
            echo "EMAILS_FROM_EMAIL=${EMAILS_FROM_EMAIL:-}"
            echo "EMAILS_FROM_NAME=${EMAILS_FROM_NAME:-WiseManPalace}"
            echo "POSTGRES_SERVER=db"
            echo "POSTGRES_PORT=${POSTGRES_PORT}"
            echo "POSTGRES_DB=${POSTGRES_DB}"
            echo "POSTGRES_USER=${POSTGRES_USER}"
            echo "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}"
            echo "SENTRY_DSN=${SENTRY_DSN:-}"
            echo "DOCKER_IMAGE_BACKEND=${DOCKER_IMAGE_BACKEND}"
            echo "DOCKER_IMAGE_FRONTEND=${DOCKER_IMAGE_FRONTEND}"
            echo "TAG=${TAG}"
          } > .env
          
          # Find Docker command
          DOCKER_CMD=""
          for cmd in docker /usr/bin/docker /usr/local/bin/docker /snap/bin/docker; do
            if $cmd --version &>/dev/null; then
              DOCKER_CMD="$cmd"
              echo "Docker found at: $DOCKER_CMD"
              break
            fi
          done
          
          if [ -z "$DOCKER_CMD" ]; then
            echo "ERROR: Docker not found"
            exit 1
          fi
          
          # Create network if needed
          if ! $DOCKER_CMD network inspect traefik-public &>/dev/null; then
            $DOCKER_CMD network create traefik-public
          fi
          
          # Clean up Docker build cache if space is low
          echo "Checking disk space..."
          DISK_USAGE=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
          if [ "$DISK_USAGE" -gt 80 ]; then
            echo "Disk usage is ${DISK_USAGE}%, cleaning Docker build cache..."
            $DOCKER_CMD builder prune -af --filter "until=24h" || true
            $DOCKER_CMD image prune -af --filter "until=24h" || true
          fi
          
          echo "Building Docker images..."
          echo "Start time: $(date)"
          echo "Docker version: $($DOCKER_CMD --version)"
          echo "Available disk: $(df -h / | tail -1 | awk '{print $4}')"
          
          BUILD_LOG="/tmp/docker-build-$(date +%s).log"
          
          # Build with longer timeout (45 minutes = 2700 seconds)
          # Use --no-cache for fresh builds if you're having issues
          if timeout 2700 $DOCKER_CMD compose --progress=plain -f docker-compose.yml build 2>&1 | tee "$BUILD_LOG"; then
            echo "✓ Build completed at $(date)"
          else
            EXIT_CODE=$?
            echo "ERROR: Build failed (exit: $EXIT_CODE) at $(date)"
            echo "=== Last 100 lines ==="
            tail -100 "$BUILD_LOG"
            echo "=== Docker status ==="
            $DOCKER_CMD ps -a | head -20 || true
            $DOCKER_CMD system df || true
            exit 1
          fi
          
          echo "Starting services..."
          if ! $DOCKER_CMD compose -f docker-compose.yml up -d; then
            echo "ERROR: Services failed to start"
            $DOCKER_CMD compose logs prestart || true
            $DOCKER_CMD compose ps -a
            exit 1
          fi
          
          sleep 5
          
          # Check prestart
          PRESTART_CONTAINER=$($DOCKER_CMD compose ps -q prestart 2>/dev/null || true)
          if [ -n "$PRESTART_CONTAINER" ]; then
            PRESTART_STATUS=$($DOCKER_CMD inspect $PRESTART_CONTAINER --format='{{.State.Status}}' 2>/dev/null || echo "unknown")
            if [ "$PRESTART_STATUS" = "exited" ]; then
              PRESTART_EXIT=$($DOCKER_CMD inspect $PRESTART_CONTAINER --format='{{.State.ExitCode}}' 2>/dev/null || echo "0")
              if [ "$PRESTART_EXIT" != "0" ] && [ "$PRESTART_EXIT" != "unknown" ]; then
                echo "ERROR: Prestart failed with exit $PRESTART_EXIT"
                $DOCKER_CMD compose logs prestart
                exit 1
              fi
            fi
          fi
          
          # Restart backend supervisor
          BACKEND_CONTAINER=$($DOCKER_CMD compose ps -q backend 2>/dev/null || true)
          if [ -n "$BACKEND_CONTAINER" ]; then
            $DOCKER_CMD exec $BACKEND_CONTAINER supervisorctl restart all || true
          fi
          
          echo "✓ Deployment completed!"
          $DOCKER_CMD compose ps
          ENDSSH
            then
              echo "✓ Deployment completed successfully"
              exit 0
            else
              SSH_EXIT_CODE=$?
              SSH_RETRY_COUNT=$((SSH_RETRY_COUNT + 1))
              if [ $SSH_RETRY_COUNT -lt $MAX_SSH_RETRIES ]; then
                echo "⚠ SSH failed (exit: $SSH_EXIT_CODE), retrying..."
                sleep $SSH_RETRY_DELAY
                SSH_RETRY_DELAY=$((SSH_RETRY_DELAY * 2))
              else
                echo "✗ Failed after $MAX_SSH_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Verify deployment
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          APP_DIR: ${{ secrets.APP_DIR || '/root/code/finance-tracker' }}
        run: |
          ssh -o StrictHostKeyChecking=accept-new \
              -o ServerAliveInterval=60 \
              ${SERVER_USER}@${SERVER_HOST} \
            "export PATH=\$PATH:/usr/bin:/usr/local/bin && cd ${APP_DIR} && docker compose ps && docker compose logs --tail=20 backend"