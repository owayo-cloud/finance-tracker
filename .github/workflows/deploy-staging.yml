name: Deploy to Staging

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: false
        default: 'staging'
      skip_pull:
        description: 'Skip pulling images (use existing)'
        required: false
        type: boolean
        default: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: staging
    env:
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY_STAGING || secrets.SSH_PRIVATE_KEY || '' }}
      SERVER_USER: ${{ secrets.SERVER_USER_STAGING || secrets.SERVER_USER }}
      SERVER_HOST: ${{ secrets.SERVER_HOST_STAGING || secrets.SERVER_HOST }}
      APP_DIR: ${{ secrets.APP_DIR_STAGING || secrets.APP_DIR || '/root/code/finance-tracker-staging' }}
      STACK_NAME: ${{ secrets.STACK_NAME_STAGING || 'staging' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup SSH
        if: ${{ env.SSH_PRIVATE_KEY != '' }}
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST_STAGING || secrets.SERVER_HOST }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H "$SERVER_HOST" >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not add $SERVER_HOST to known_hosts"

      - name: Deploy to staging server
        env:
          SERVER_USER: ${{ secrets.SERVER_USER_STAGING || secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST_STAGING || secrets.SERVER_HOST }}
          APP_DIR: ${{ secrets.APP_DIR_STAGING || secrets.APP_DIR }}
          REPO_DEPLOY_KEY_B64: ${{ secrets.REPO_DEPLOY_KEY_B64 || '' }}
          REPO_DEPLOY_KEY: ${{ secrets.REPO_DEPLOY_KEY || '' }}
          REPO_PAT: ${{ secrets.REPO_PAT || '' }}
          GIT_REPOSITORY: ${{ github.repository }}
        run: |
          ssh ${SERVER_USER}@${SERVER_HOST} << ENDSSH
            set -e
            APP_DIR_PATH="${APP_DIR:-/root/code/finance-tracker-staging}"
            
            # Setup deploy key/authentication first (needed for both clone and fetch)
            if [ -n "${REPO_DEPLOY_KEY_B64}" ]; then
              echo "Setting up base64 deploy key..."
              mkdir -p ~/.ssh
              echo "${REPO_DEPLOY_KEY_B64}" | base64 --decode > ~/.ssh/github_deploy_key
              chmod 600 ~/.ssh/github_deploy_key
              ssh-keyscan -H github.com >> ~/.ssh/known_hosts 2>/dev/null
              export GIT_SSH_COMMAND="ssh -i ~/.ssh/github_deploy_key -o StrictHostKeyChecking=yes"
            elif [ -n "${REPO_DEPLOY_KEY}" ]; then
              echo "Setting up deploy key..."
              mkdir -p ~/.ssh
              echo "${REPO_DEPLOY_KEY}" > ~/.ssh/github_deploy_key
              chmod 600 ~/.ssh/github_deploy_key
              ssh-keyscan -H github.com >> ~/.ssh/known_hosts 2>/dev/null
              export GIT_SSH_COMMAND="ssh -i ~/.ssh/github_deploy_key -o StrictHostKeyChecking=yes"
            elif [ -n "${REPO_PAT}" ]; then
              echo "Using PAT for authentication..."
              export GIT_AUTH_URL="https://x-access-token:${REPO_PAT}@github.com/${GIT_REPOSITORY}.git"
            fi
            
            # Clone repository if it doesn't exist
            if [ ! -d "\${APP_DIR_PATH}/.git" ]; then
              echo "Repository not found on server. Cloning fresh copy..."
              rm -rf "\${APP_DIR_PATH}"
              mkdir -p "\${APP_DIR_PATH}"
              if [ -n "\${GIT_AUTH_URL}" ]; then
                git clone "\${GIT_AUTH_URL}" "\${APP_DIR_PATH}"
              elif [ -n "\${GIT_SSH_COMMAND}" ]; then
                git clone "git@github.com:${GIT_REPOSITORY}.git" "\${APP_DIR_PATH}"
              else
                echo "No authentication configured - attempting HTTPS clone (requires public repo)..."
                git clone "https://github.com/${GIT_REPOSITORY}.git" "\${APP_DIR_PATH}"
              fi
            fi
            
            cd "\${APP_DIR_PATH}"
            
            # Pull latest code from GitHub
            echo "Fetching latest code..."
            git fetch origin
            git reset --hard origin/dev
            
            # Set environment variables
            export DOMAIN=${{ secrets.DOMAIN_STAGING }}
            export STACK_NAME=${{ secrets.STACK_NAME_STAGING }}
            export ENVIRONMENT=staging
            export FRONTEND_HOST=${{ secrets.FRONTEND_HOST_STAGING || format('https://dashboard.{0}', secrets.DOMAIN_STAGING) }}
            export BACKEND_CORS_ORIGINS=${{ secrets.BACKEND_CORS_ORIGINS_STAGING || format('https://dashboard.{0},https://api.{0}', secrets.DOMAIN_STAGING) }}
            export SECRET_KEY=${{ secrets.SECRET_KEY }}
            export FIRST_SUPERUSER=${{ secrets.FIRST_SUPERUSER }}
            export FIRST_SUPERUSER_PASSWORD=${{ secrets.FIRST_SUPERUSER_PASSWORD }}
            export SMTP_HOST=${{ secrets.SMTP_HOST }}
            export SMTP_USER=${{ secrets.SMTP_USER }}
            export SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
            export EMAILS_FROM_EMAIL=${{ secrets.EMAILS_FROM_EMAIL }}
            export POSTGRES_SERVER=db
            export POSTGRES_PORT=${{ secrets.POSTGRES_PORT || '5432' }}
            export POSTGRES_DB=${{ secrets.POSTGRES_DB_STAGING || 'app_staging' }}
            export POSTGRES_USER=${{ secrets.POSTGRES_USER || 'postgres' }}
            export POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            export SENTRY_DSN=${{ secrets.SENTRY_DSN || '' }}
            export DOCKER_IMAGE_BACKEND=ghcr.io/${{ github.repository }}-backend
            export DOCKER_IMAGE_FRONTEND=ghcr.io/${{ github.repository }}-frontend
            export TAG=${{ inputs.image_tag || 'staging' }}
            
            # Pull pre-built images from GitHub Container Registry (unless skipped)
            if [ "${{ inputs.skip_pull }}" != "true" ]; then
              echo "Pulling Docker images from registry..."
              echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
              docker pull \${DOCKER_IMAGE_BACKEND}:\${TAG} || echo "Warning: Failed to pull backend image"
              docker pull \${DOCKER_IMAGE_FRONTEND}:\${TAG} || echo "Warning: Failed to pull frontend image"
            else
              echo "Skipping image pull (using existing images)..."
            fi
            
            echo "Starting services..."
            docker compose -f docker-compose.yml --project-name ${STACK_NAME} up -d --no-build
            
            # Restart supervisor processes in backend container
            echo "Restarting supervisor processes..."
            BACKEND_CONTAINER=$(docker compose --project-name ${STACK_NAME} ps -q backend)
            if [ ! -z "$BACKEND_CONTAINER" ]; then
              docker exec $BACKEND_CONTAINER supervisorctl restart all || true
            fi
            
            echo "Deployment completed successfully!"
            
            # Show service status
            docker compose --project-name ${STACK_NAME} ps
          ENDSSH

      - name: Verify deployment
        env:
          DOMAIN: ${{ secrets.DOMAIN_STAGING }}
        run: |
          ssh ${SERVER_USER}@${SERVER_HOST} << ENDSSH
            set -e
            APP_DIR_PATH="${APP_DIR:-/root/code/finance-tracker-staging}"
            cd "\${APP_DIR_PATH}"
            
            echo "=== Checking service status ==="
            docker compose --project-name ${STACK_NAME} ps
            
            echo "=== Waiting for backend container to be healthy ==="
            BACKEND_CONTAINER=$(docker compose --project-name ${STACK_NAME} ps -q backend)
            if [ -z "$BACKEND_CONTAINER" ]; then
              echo "ERROR: Backend container not found!"
              exit 1
            fi
            
            # Wait for Docker healthcheck to pass
            echo "Waiting for backend container health check..."
            for i in {1..60}; do
              HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' $BACKEND_CONTAINER 2>/dev/null || echo "no-health")
              if [ "$HEALTH_STATUS" = "healthy" ]; then
                echo "✓ Backend container is healthy"
                break
              fi
              if [ $i -eq 60 ]; then
                echo "WARNING: Backend container health check timeout (waited 2 minutes)"
                echo "Current status: $HEALTH_STATUS"
                echo "Continuing with manual health checks..."
              else
                echo "Attempt $i/60: Container status: $HEALTH_STATUS (waiting...)"
                sleep 2
              fi
            done
            
            echo "=== Checking supervisor processes ==="
            docker exec $BACKEND_CONTAINER supervisorctl status || true
            
            echo "=== Checking backend health endpoint (internal) ==="
            for i in {1..30}; do
              if docker exec $BACKEND_CONTAINER curl -f http://localhost:8000/api/v1/utils/health-check/ > /dev/null 2>&1; then
                echo "✓ Backend health check passed (internal)"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "ERROR: Backend health check failed after 30 attempts"
                exit 1
              fi
              echo "Attempt $i/30: Waiting for backend to be ready..."
              sleep 2
            done
            
            echo "=== Checking backend health endpoint (external) ==="
            if [ -n "${DOMAIN}" ]; then
              BACKEND_URL="https://api.${DOMAIN}/api/v1/utils/health-check/"
              echo "Testing: $BACKEND_URL"
              for i in {1..20}; do
                if curl -f -k "$BACKEND_URL" > /dev/null 2>&1; then
                  echo "✓ Backend health check passed (external)"
                  break
                fi
                if [ $i -eq 20 ]; then
                  echo "WARNING: External backend health check failed (may be SSL/certificate issue)"
                  echo "Internal health check passed, so deployment is likely successful"
                fi
                echo "Attempt $i/20: Waiting for external endpoint..."
                sleep 3
              done
            else
              echo "DOMAIN not set, skipping external health check"
            fi
            
            echo "=== Deployment verification completed successfully ==="
          ENDSSH
