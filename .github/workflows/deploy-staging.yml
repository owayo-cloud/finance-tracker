name: Deploy to Staging

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: false
        default: 'staging'
      skip_pull:
        description: 'Skip pulling images (use existing)'
        required: false
        type: boolean
        default: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: staging
    env:
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY_STAGING || secrets.SSH_PRIVATE_KEY || '' }}
      SERVER_USER: ${{ secrets.SERVER_USER_STAGING || secrets.SERVER_USER }}
      SERVER_HOST: ${{ secrets.SERVER_HOST_STAGING || secrets.SERVER_HOST }}
      APP_DIR: ${{ secrets.APP_DIR_STAGING || secrets.APP_DIR || '/root/code/finance-tracker-staging' }}
      STACK_NAME: ${{ secrets.STACK_NAME_STAGING || 'staging' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup SSH
        if: ${{ env.SSH_PRIVATE_KEY != '' }}
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST_STAGING || secrets.SERVER_HOST }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H "$SERVER_HOST" >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not add $SERVER_HOST to known_hosts"

      - name: Deploy to staging server
        env:
          SERVER_USER: ${{ secrets.SERVER_USER_STAGING || secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST_STAGING || secrets.SERVER_HOST }}
          APP_DIR: ${{ secrets.APP_DIR_STAGING || secrets.APP_DIR }}
          STACK_NAME: ${{ secrets.STACK_NAME_STAGING || 'staging' }}
          REPO_DEPLOY_KEY: ${{ secrets.REPO_DEPLOY_KEY || '' }}
          GIT_REPOSITORY: ${{ github.repository }}
          DOMAIN: ${{ secrets.DOMAIN_STAGING }}
          FRONTEND_HOST: ${{ secrets.FRONTEND_HOST_STAGING || format('https://dashboard.{0}', secrets.DOMAIN_STAGING) }}
          BACKEND_CORS_ORIGINS: ${{ secrets.BACKEND_CORS_ORIGINS_STAGING || format('https://dashboard.{0},https://api.{0}', secrets.DOMAIN_STAGING) }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          FIRST_SUPERUSER: ${{ secrets.FIRST_SUPERUSER }}
          FIRST_SUPERUSER_PASSWORD: ${{ secrets.FIRST_SUPERUSER_PASSWORD }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          EMAILS_FROM_EMAIL: ${{ secrets.EMAILS_FROM_EMAIL }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT || '5432' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB_STAGING || 'app_staging' }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'postgres' }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN || '' }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          IMAGE_TAG: ${{ inputs.image_tag || 'staging' }}
          SKIP_PULL: ${{ inputs.skip_pull }}
        run: |
          ssh -A -o StrictHostKeyChecking=accept-new ${SERVER_USER}@${SERVER_HOST} \
            "APP_DIR='$APP_DIR' \
             STACK_NAME='$STACK_NAME' \
             GIT_REPOSITORY='$GIT_REPOSITORY' \
             DOMAIN='$DOMAIN' \
             FRONTEND_HOST='$FRONTEND_HOST' \
             BACKEND_CORS_ORIGINS='$BACKEND_CORS_ORIGINS' \
             SECRET_KEY='$SECRET_KEY' \
             FIRST_SUPERUSER='$FIRST_SUPERUSER' \
             FIRST_SUPERUSER_PASSWORD='$FIRST_SUPERUSER_PASSWORD' \
             SMTP_HOST='$SMTP_HOST' \
             SMTP_USER='$SMTP_USER' \
             SMTP_PASSWORD='$SMTP_PASSWORD' \
             EMAILS_FROM_EMAIL='$EMAILS_FROM_EMAIL' \
             POSTGRES_PORT='$POSTGRES_PORT' \
             POSTGRES_DB='$POSTGRES_DB' \
             POSTGRES_USER='$POSTGRES_USER' \
             POSTGRES_PASSWORD='$POSTGRES_PASSWORD' \
             SENTRY_DSN='$SENTRY_DSN' \
             GITHUB_TOKEN='$GITHUB_TOKEN' \
             GITHUB_ACTOR='$GITHUB_ACTOR' \
             IMAGE_TAG='$IMAGE_TAG' \
             SKIP_PULL='$SKIP_PULL' \
             REPO_DEPLOY_KEY='$REPO_DEPLOY_KEY' \
             bash -s" << 'ENDSSH'
            set -e
            
            APP_DIR_PATH="${APP_DIR:-/root/code/finance-tracker-staging}"
            
            # Setup deploy key for GitHub if provided
            if [ -n "${REPO_DEPLOY_KEY}" ]; then
              echo "Setting up deploy key..."
              mkdir -p ~/.ssh
              echo "${REPO_DEPLOY_KEY}" > ~/.ssh/github_deploy_key
              chmod 600 ~/.ssh/github_deploy_key
              ssh-keyscan -H github.com >> ~/.ssh/known_hosts 2>/dev/null
              export GIT_SSH_COMMAND="ssh -i ~/.ssh/github_deploy_key -o StrictHostKeyChecking=accept-new"
            fi
            
            # Clone repository if it doesn't exist
            if [ ! -d "${APP_DIR_PATH}/.git" ]; then
              echo "Repository not found on server. Cloning fresh copy..."
              rm -rf "${APP_DIR_PATH}"
              mkdir -p "${APP_DIR_PATH}"
              if [ -n "${GIT_SSH_COMMAND}" ]; then
                git clone "git@github.com:${GIT_REPOSITORY}.git" "${APP_DIR_PATH}"
              else
                echo "No authentication configured - attempting HTTPS clone (requires public repo)..."
                git clone "https://github.com/${GIT_REPOSITORY}.git" "${APP_DIR_PATH}"
              fi
            fi
            
            cd "${APP_DIR_PATH}"
            
            # Pull latest code from GitHub
            echo "Fetching latest code..."
            git fetch origin
            git reset --hard origin/dev
            
            # Set environment variables for docker-compose
            export ENVIRONMENT=staging
            export POSTGRES_SERVER=db
            export DOCKER_IMAGE_BACKEND=ghcr.io/${GIT_REPOSITORY}-backend
            export DOCKER_IMAGE_FRONTEND=ghcr.io/${GIT_REPOSITORY}-frontend
            export TAG=${IMAGE_TAG:-staging}
            
            # Pull pre-built images from GitHub Container Registry (unless skipped)
            if [ "${SKIP_PULL}" != "true" ]; then
              echo "Pulling Docker images from registry..."
              echo "${GITHUB_TOKEN}" | docker login ghcr.io -u ${GITHUB_ACTOR} --password-stdin
              docker pull ${DOCKER_IMAGE_BACKEND}:${TAG} || echo "Warning: Failed to pull backend image"
              docker pull ${DOCKER_IMAGE_FRONTEND}:${TAG} || echo "Warning: Failed to pull frontend image"
            else
              echo "Skipping image pull (using existing images)..."
            fi
            
            echo "Starting services..."
            docker compose -f docker-compose.yml --project-name ${STACK_NAME} up -d --no-build
            
            # Restart supervisor processes in backend container
            echo "Restarting supervisor processes..."
            BACKEND_CONTAINER=$(docker compose --project-name ${STACK_NAME} ps -q backend)
            if [ -n "$BACKEND_CONTAINER" ]; then
              docker exec $BACKEND_CONTAINER supervisorctl restart all || true
            fi
            
            echo "Deployment completed successfully!"
            
            # Show service status
            docker compose --project-name ${STACK_NAME} ps
          ENDSSH

      - name: Verify deployment
        env:
          DOMAIN: ${{ secrets.DOMAIN_STAGING }}
          STACK_NAME: ${{ secrets.STACK_NAME_STAGING || 'staging' }}
          APP_DIR: ${{ secrets.APP_DIR_STAGING || secrets.APP_DIR }}
        run: |
          ssh -o StrictHostKeyChecking=accept-new ${SERVER_USER}@${SERVER_HOST} \
            "APP_DIR='$APP_DIR' \
             STACK_NAME='$STACK_NAME' \
             DOMAIN='$DOMAIN' \
             bash -s" << 'ENDSSH'
            set -e
            
            APP_DIR_PATH="${APP_DIR:-/root/code/finance-tracker-staging}"
            cd "${APP_DIR_PATH}"
            
            echo "=== Checking service status ==="
            docker compose --project-name ${STACK_NAME} ps
            
            echo "=== Waiting for backend container to be healthy ==="
            BACKEND_CONTAINER=$(docker compose --project-name ${STACK_NAME} ps -q backend)
            if [ -z "$BACKEND_CONTAINER" ]; then
              echo "ERROR: Backend container not found!"
              exit 1
            fi
            
            # Wait for Docker healthcheck to pass
            echo "Waiting for backend container health check..."
            for i in {1..60}; do
              HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' $BACKEND_CONTAINER 2>/dev/null || echo "no-health")
              if [ "$HEALTH_STATUS" = "healthy" ]; then
                echo "✓ Backend container is healthy"
                break
              fi
              if [ $i -eq 60 ]; then
                echo "WARNING: Backend container health check timeout (waited 2 minutes)"
                echo "Current status: $HEALTH_STATUS"
                echo "Continuing with manual health checks..."
              else
                echo "Attempt $i/60: Container status: $HEALTH_STATUS (waiting...)"
                sleep 2
              fi
            done
            
            echo "=== Checking supervisor processes ==="
            docker exec $BACKEND_CONTAINER supervisorctl status || true
            
            echo "=== Checking backend health endpoint (internal) ==="
            for i in {1..30}; do
              if docker exec $BACKEND_CONTAINER curl -f http://localhost:8000/api/v1/utils/health-check/ > /dev/null 2>&1; then
                echo "✓ Backend health check passed (internal)"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "ERROR: Backend health check failed after 30 attempts"
                exit 1
              fi
              echo "Attempt $i/30: Waiting for backend to be ready..."
              sleep 2
            done
            
            echo "=== Checking backend health endpoint (external) ==="
            if [ -n "${DOMAIN}" ]; then
              BACKEND_URL="https://api.${DOMAIN}/api/v1/utils/health-check/"
              echo "Testing: $BACKEND_URL"
              for i in {1..20}; do
                if curl -f -k "$BACKEND_URL" > /dev/null 2>&1; then
                  echo "✓ Backend health check passed (external)"
                  break
                fi
                if [ $i -eq 20 ]; then
                  echo "WARNING: External backend health check failed (may be SSL/certificate issue)"
                  echo "Internal health check passed, so deployment is likely successful"
                fi
                echo "Attempt $i/20: Waiting for external endpoint..."
                sleep 3
              done
            else
              echo "DOMAIN not set, skipping external health check"
            fi
            
            echo "=== Deployment verification completed successfully ==="
          ENDSSH
